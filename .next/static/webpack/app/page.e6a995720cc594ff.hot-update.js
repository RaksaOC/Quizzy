"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/hooks/useGameState.ts":
/*!***********************************!*\
  !*** ./app/hooks/useGameState.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameState: function() { return /* binding */ useGameState; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useGameState(param) {\n    let { initialRounds, timePerTurn, onGameComplete, generateQuestion } = param;\n    const [gameState, setGameState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        players: [\n            {\n                name: \"\",\n                avatar: \"\",\n                score: 0,\n                roundsWon: 0\n            },\n            {\n                name: \"\",\n                avatar: \"\",\n                score: 0,\n                roundsWon: 0\n            }\n        ],\n        currentPlayerIndex: 0,\n        timeLeft: timePerTurn,\n        currentRound: 1,\n        totalRounds: initialRounds,\n        isGameOver: false,\n        currentQuestion: null,\n        hasAnswered: [\n            false,\n            false\n        ]\n    });\n    const [isTimerRunning, setIsTimerRunning] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Timer effect\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let timer;\n        if (isTimerRunning && gameState.timeLeft > 0 && !gameState.isGameOver) {\n            timer = setInterval(()=>{\n                setGameState((prev)=>({\n                        ...prev,\n                        timeLeft: prev.timeLeft - 1\n                    }));\n            }, 1000);\n        }\n        return ()=>clearInterval(timer);\n    }, [\n        isTimerRunning,\n        gameState.timeLeft,\n        gameState.isGameOver\n    ]);\n    // Watch for time running out\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (gameState.timeLeft === 0 && !gameState.isGameOver) {\n            handleTimeUp();\n        }\n    }, [\n        gameState.timeLeft\n    ]);\n    const initializePlayers = (player1Name, player1Avatar, player2Name, player2Avatar)=>{\n        setGameState((prev)=>({\n                ...prev,\n                players: [\n                    {\n                        name: player1Name,\n                        avatar: player1Avatar,\n                        score: 0,\n                        roundsWon: 0\n                    },\n                    {\n                        name: player2Name,\n                        avatar: player2Avatar,\n                        score: 0,\n                        roundsWon: 0\n                    }\n                ],\n                currentQuestion: generateQuestion(),\n                timeLeft: timePerTurn,\n                currentPlayerIndex: 0,\n                hasAnswered: [\n                    false,\n                    false\n                ]\n            }));\n        setIsTimerRunning(true);\n    };\n    const moveToNextPlayer = (currentState)=>{\n        const nextPlayerIndex = 1 - currentState.currentPlayerIndex;\n        // If both players have answered, move to next round\n        if (currentState.hasAnswered[0] && currentState.hasAnswered[1]) {\n            // Determine round winner\n            const roundScores = [\n                currentState.players[0].score,\n                currentState.players[1].score\n            ];\n            if (roundScores[0] > roundScores[1]) {\n                currentState.players[0].roundsWon++;\n            } else if (roundScores[1] > roundScores[0]) {\n                currentState.players[1].roundsWon++;\n            }\n            // Check if game is over\n            if (currentState.currentRound === currentState.totalRounds) {\n                currentState.isGameOver = true;\n                const winner = currentState.players[0].score > currentState.players[1].score ? currentState.players[0] : currentState.players[1];\n                onGameComplete === null || onGameComplete === void 0 ? void 0 : onGameComplete(winner);\n                return currentState;\n            }\n            // Setup next round\n            return {\n                ...currentState,\n                currentRound: currentState.currentRound + 1,\n                currentPlayerIndex: 0,\n                hasAnswered: [\n                    false,\n                    false\n                ],\n                timeLeft: timePerTurn,\n                currentQuestion: generateQuestion()\n            };\n        }\n        // Just move to next player within the same round\n        return {\n            ...currentState,\n            currentPlayerIndex: nextPlayerIndex,\n            timeLeft: timePerTurn\n        };\n    };\n    const handleAnswer = function(playerIndex, isCorrect) {\n        let timeBonus = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        setGameState((prev)=>{\n            // Update current player's answer and score\n            const newState = {\n                ...prev\n            };\n            const points = isCorrect ? 10 + timeBonus : 0;\n            newState.players[playerIndex].score += points;\n            newState.hasAnswered[playerIndex] = true;\n            // Move to next player or round\n            const updatedState = moveToNextPlayer(newState);\n            // Restart timer for next player/round if game isn't over\n            if (!updatedState.isGameOver) {\n                setIsTimerRunning(true);\n            }\n            return updatedState;\n        });\n    };\n    const handleTimeUp = ()=>{\n        setIsTimerRunning(false);\n        // Auto-submit wrong answer for current player if they haven't answered\n        if (!gameState.hasAnswered[gameState.currentPlayerIndex]) {\n            handleAnswer(gameState.currentPlayerIndex, false, 0);\n        }\n    };\n    const forfeitGame = (playerIndex)=>{\n        setGameState((prev)=>{\n            const newState = {\n                ...prev\n            };\n            newState.isGameOver = true;\n            const winner = newState.players[1 - playerIndex]; // Other player wins\n            onGameComplete === null || onGameComplete === void 0 ? void 0 : onGameComplete(winner);\n            return newState;\n        });\n        setIsTimerRunning(false);\n    };\n    return {\n        gameState,\n        initializePlayers,\n        handleAnswer,\n        forfeitGame,\n        isTimerRunning\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9ob29rcy91c2VHYW1lU3RhdGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlEO0FBMkJsRCxTQUFTRSxhQUFhLEtBS1Q7UUFMUyxFQUMzQkMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLGNBQWMsRUFDZEMsZ0JBQWdCLEVBQ0UsR0FMUztJQU0zQixNQUFNLENBQUNDLFdBQVdDLGFBQWEsR0FBR1IsK0NBQVFBLENBQVk7UUFDcERTLFNBQVM7WUFDUDtnQkFBRUMsTUFBTTtnQkFBSUMsUUFBUTtnQkFBSUMsT0FBTztnQkFBR0MsV0FBVztZQUFFO1lBQy9DO2dCQUFFSCxNQUFNO2dCQUFJQyxRQUFRO2dCQUFJQyxPQUFPO2dCQUFHQyxXQUFXO1lBQUU7U0FDaEQ7UUFDREMsb0JBQW9CO1FBQ3BCQyxVQUFVWDtRQUNWWSxjQUFjO1FBQ2RDLGFBQWFkO1FBQ2JlLFlBQVk7UUFDWkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1lBQUM7WUFBTztTQUFNO0lBQzdCO0lBRUEsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHdEIsK0NBQVFBLENBQUM7SUFFckQsZUFBZTtJQUNmQyxnREFBU0EsQ0FBQztRQUNSLElBQUlzQjtRQUNKLElBQUlGLGtCQUFrQmQsVUFBVVEsUUFBUSxHQUFHLEtBQUssQ0FBQ1IsVUFBVVcsVUFBVSxFQUFFO1lBQ3JFSyxRQUFRQyxZQUFZO2dCQUNsQmhCLGFBQWEsQ0FBQ2lCLE9BQVU7d0JBQ3RCLEdBQUdBLElBQUk7d0JBQ1BWLFVBQVVVLEtBQUtWLFFBQVEsR0FBRztvQkFDNUI7WUFDRixHQUFHO1FBQ0w7UUFDQSxPQUFPLElBQU1XLGNBQWNIO0lBQzdCLEdBQUc7UUFBQ0Y7UUFBZ0JkLFVBQVVRLFFBQVE7UUFBRVIsVUFBVVcsVUFBVTtLQUFDO0lBRTdELDZCQUE2QjtJQUM3QmpCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSU0sVUFBVVEsUUFBUSxLQUFLLEtBQUssQ0FBQ1IsVUFBVVcsVUFBVSxFQUFFO1lB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YSxXQUFXLENBQUNiLFVBQVVPLGtCQUFrQixDQUFDLEVBQUU7WUFDeER3QixhQUFhL0IsVUFBVU8sa0JBQWtCLEVBQUUsT0FBTztRQUNwRDtJQUNGO0lBRUEsTUFBTStCLGNBQWMsQ0FBQ047UUFDbkIvQixhQUFhLENBQUNpQjtZQUNaLE1BQU1pQixXQUFXO2dCQUFFLEdBQUdqQixJQUFJO1lBQUM7WUFDM0JpQixTQUFTeEIsVUFBVSxHQUFHO1lBQ3RCLE1BQU1tQixTQUFTSyxTQUFTakMsT0FBTyxDQUFDLElBQUk4QixZQUFZLEVBQUUsb0JBQW9CO1lBQ3RFbEMsMkJBQUFBLHFDQUFBQSxlQUFpQmdDO1lBQ2pCLE9BQU9LO1FBQ1Q7UUFDQXBCLGtCQUFrQjtJQUNwQjtJQUVBLE9BQU87UUFDTGY7UUFDQXFCO1FBQ0FVO1FBQ0FPO1FBQ0F4QjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2hvb2tzL3VzZUdhbWVTdGF0ZS50cz83OWUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxheWVyIHtcbiAgbmFtZTogc3RyaW5nO1xuICBhdmF0YXI6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91bmRzV29uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2FtZVN0YXRlIHtcbiAgcGxheWVyczogW1BsYXllciwgUGxheWVyXTtcbiAgY3VycmVudFBsYXllckluZGV4OiBudW1iZXI7XG4gIHRpbWVMZWZ0OiBudW1iZXI7XG4gIGN1cnJlbnRSb3VuZDogbnVtYmVyO1xuICB0b3RhbFJvdW5kczogbnVtYmVyO1xuICBpc0dhbWVPdmVyOiBib29sZWFuO1xuICBjdXJyZW50UXVlc3Rpb246IGFueTtcbiAgaGFzQW5zd2VyZWQ6IGJvb2xlYW5bXTtcbn1cblxuaW50ZXJmYWNlIFVzZUdhbWVTdGF0ZVByb3BzIHtcbiAgaW5pdGlhbFJvdW5kczogbnVtYmVyO1xuICB0aW1lUGVyVHVybjogbnVtYmVyO1xuICBvbkdhbWVDb21wbGV0ZT86ICh3aW5uZXI6IFBsYXllcikgPT4gdm9pZDtcbiAgZ2VuZXJhdGVRdWVzdGlvbjogKCkgPT4gYW55O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR2FtZVN0YXRlKHtcbiAgaW5pdGlhbFJvdW5kcyxcbiAgdGltZVBlclR1cm4sXG4gIG9uR2FtZUNvbXBsZXRlLFxuICBnZW5lcmF0ZVF1ZXN0aW9uLFxufTogVXNlR2FtZVN0YXRlUHJvcHMpIHtcbiAgY29uc3QgW2dhbWVTdGF0ZSwgc2V0R2FtZVN0YXRlXSA9IHVzZVN0YXRlPEdhbWVTdGF0ZT4oe1xuICAgIHBsYXllcnM6IFtcbiAgICAgIHsgbmFtZTogXCJcIiwgYXZhdGFyOiBcIlwiLCBzY29yZTogMCwgcm91bmRzV29uOiAwIH0sXG4gICAgICB7IG5hbWU6IFwiXCIsIGF2YXRhcjogXCJcIiwgc2NvcmU6IDAsIHJvdW5kc1dvbjogMCB9LFxuICAgIF0sXG4gICAgY3VycmVudFBsYXllckluZGV4OiAwLFxuICAgIHRpbWVMZWZ0OiB0aW1lUGVyVHVybixcbiAgICBjdXJyZW50Um91bmQ6IDEsXG4gICAgdG90YWxSb3VuZHM6IGluaXRpYWxSb3VuZHMsXG4gICAgaXNHYW1lT3ZlcjogZmFsc2UsXG4gICAgY3VycmVudFF1ZXN0aW9uOiBudWxsLFxuICAgIGhhc0Fuc3dlcmVkOiBbZmFsc2UsIGZhbHNlXSxcbiAgfSk7XG5cbiAgY29uc3QgW2lzVGltZXJSdW5uaW5nLCBzZXRJc1RpbWVyUnVubmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gVGltZXIgZWZmZWN0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHRpbWVyOiBOb2RlSlMuVGltZW91dDtcbiAgICBpZiAoaXNUaW1lclJ1bm5pbmcgJiYgZ2FtZVN0YXRlLnRpbWVMZWZ0ID4gMCAmJiAhZ2FtZVN0YXRlLmlzR2FtZU92ZXIpIHtcbiAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBzZXRHYW1lU3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICB0aW1lTGVmdDogcHJldi50aW1lTGVmdCAtIDEsXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gIH0sIFtpc1RpbWVyUnVubmluZywgZ2FtZVN0YXRlLnRpbWVMZWZ0LCBnYW1lU3RhdGUuaXNHYW1lT3Zlcl0pO1xuXG4gIC8vIFdhdGNoIGZvciB0aW1lIHJ1bm5pbmcgb3V0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdhbWVTdGF0ZS50aW1lTGVmdCA9PT0gMCAmJiAhZ2FtZVN0YXRlLmlzR2FtZU92ZXIpIHtcbiAgICAgIGhhbmRsZVRpbWVVcCgpO1xuICAgIH1cbiAgfSwgW2dhbWVTdGF0ZS50aW1lTGVmdF0pO1xuXG4gIGNvbnN0IGluaXRpYWxpemVQbGF5ZXJzID0gKFxuICAgIHBsYXllcjFOYW1lOiBzdHJpbmcsXG4gICAgcGxheWVyMUF2YXRhcjogc3RyaW5nLFxuICAgIHBsYXllcjJOYW1lOiBzdHJpbmcsXG4gICAgcGxheWVyMkF2YXRhcjogc3RyaW5nXG4gICkgPT4ge1xuICAgIHNldEdhbWVTdGF0ZSgocHJldikgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBwbGF5ZXJzOiBbXG4gICAgICAgIHsgbmFtZTogcGxheWVyMU5hbWUsIGF2YXRhcjogcGxheWVyMUF2YXRhciwgc2NvcmU6IDAsIHJvdW5kc1dvbjogMCB9LFxuICAgICAgICB7IG5hbWU6IHBsYXllcjJOYW1lLCBhdmF0YXI6IHBsYXllcjJBdmF0YXIsIHNjb3JlOiAwLCByb3VuZHNXb246IDAgfSxcbiAgICAgIF0sXG4gICAgICBjdXJyZW50UXVlc3Rpb246IGdlbmVyYXRlUXVlc3Rpb24oKSxcbiAgICAgIHRpbWVMZWZ0OiB0aW1lUGVyVHVybixcbiAgICAgIGN1cnJlbnRQbGF5ZXJJbmRleDogMCxcbiAgICAgIGhhc0Fuc3dlcmVkOiBbZmFsc2UsIGZhbHNlXSxcbiAgICB9KSk7XG4gICAgc2V0SXNUaW1lclJ1bm5pbmcodHJ1ZSk7XG4gIH07XG5cbiAgY29uc3QgbW92ZVRvTmV4dFBsYXllciA9IChjdXJyZW50U3RhdGU6IEdhbWVTdGF0ZSk6IEdhbWVTdGF0ZSA9PiB7XG4gICAgY29uc3QgbmV4dFBsYXllckluZGV4ID0gMSAtIGN1cnJlbnRTdGF0ZS5jdXJyZW50UGxheWVySW5kZXg7XG5cbiAgICAvLyBJZiBib3RoIHBsYXllcnMgaGF2ZSBhbnN3ZXJlZCwgbW92ZSB0byBuZXh0IHJvdW5kXG4gICAgaWYgKGN1cnJlbnRTdGF0ZS5oYXNBbnN3ZXJlZFswXSAmJiBjdXJyZW50U3RhdGUuaGFzQW5zd2VyZWRbMV0pIHtcbiAgICAgIC8vIERldGVybWluZSByb3VuZCB3aW5uZXJcbiAgICAgIGNvbnN0IHJvdW5kU2NvcmVzID0gW1xuICAgICAgICBjdXJyZW50U3RhdGUucGxheWVyc1swXS5zY29yZSxcbiAgICAgICAgY3VycmVudFN0YXRlLnBsYXllcnNbMV0uc2NvcmUsXG4gICAgICBdO1xuXG4gICAgICBpZiAocm91bmRTY29yZXNbMF0gPiByb3VuZFNjb3Jlc1sxXSkge1xuICAgICAgICBjdXJyZW50U3RhdGUucGxheWVyc1swXS5yb3VuZHNXb24rKztcbiAgICAgIH0gZWxzZSBpZiAocm91bmRTY29yZXNbMV0gPiByb3VuZFNjb3Jlc1swXSkge1xuICAgICAgICBjdXJyZW50U3RhdGUucGxheWVyc1sxXS5yb3VuZHNXb24rKztcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgZ2FtZSBpcyBvdmVyXG4gICAgICBpZiAoY3VycmVudFN0YXRlLmN1cnJlbnRSb3VuZCA9PT0gY3VycmVudFN0YXRlLnRvdGFsUm91bmRzKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5pc0dhbWVPdmVyID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgd2lubmVyID1cbiAgICAgICAgICBjdXJyZW50U3RhdGUucGxheWVyc1swXS5zY29yZSA+IGN1cnJlbnRTdGF0ZS5wbGF5ZXJzWzFdLnNjb3JlXG4gICAgICAgICAgICA/IGN1cnJlbnRTdGF0ZS5wbGF5ZXJzWzBdXG4gICAgICAgICAgICA6IGN1cnJlbnRTdGF0ZS5wbGF5ZXJzWzFdO1xuICAgICAgICBvbkdhbWVDb21wbGV0ZT8uKHdpbm5lcik7XG4gICAgICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIG5leHQgcm91bmRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgICAgY3VycmVudFJvdW5kOiBjdXJyZW50U3RhdGUuY3VycmVudFJvdW5kICsgMSxcbiAgICAgICAgY3VycmVudFBsYXllckluZGV4OiAwLFxuICAgICAgICBoYXNBbnN3ZXJlZDogW2ZhbHNlLCBmYWxzZV0sXG4gICAgICAgIHRpbWVMZWZ0OiB0aW1lUGVyVHVybixcbiAgICAgICAgY3VycmVudFF1ZXN0aW9uOiBnZW5lcmF0ZVF1ZXN0aW9uKCksXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEp1c3QgbW92ZSB0byBuZXh0IHBsYXllciB3aXRoaW4gdGhlIHNhbWUgcm91bmRcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY3VycmVudFN0YXRlLFxuICAgICAgY3VycmVudFBsYXllckluZGV4OiBuZXh0UGxheWVySW5kZXgsXG4gICAgICB0aW1lTGVmdDogdGltZVBlclR1cm4sXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVBbnN3ZXIgPSAoXG4gICAgcGxheWVySW5kZXg6IG51bWJlcixcbiAgICBpc0NvcnJlY3Q6IGJvb2xlYW4sXG4gICAgdGltZUJvbnVzOiBudW1iZXIgPSAwXG4gICkgPT4ge1xuICAgIHNldEdhbWVTdGF0ZSgocHJldikgPT4ge1xuICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgcGxheWVyJ3MgYW5zd2VyIGFuZCBzY29yZVxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IC4uLnByZXYgfTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGlzQ29ycmVjdCA/IDEwICsgdGltZUJvbnVzIDogMDtcbiAgICAgIG5ld1N0YXRlLnBsYXllcnNbcGxheWVySW5kZXhdLnNjb3JlICs9IHBvaW50cztcbiAgICAgIG5ld1N0YXRlLmhhc0Fuc3dlcmVkW3BsYXllckluZGV4XSA9IHRydWU7XG5cbiAgICAgIC8vIE1vdmUgdG8gbmV4dCBwbGF5ZXIgb3Igcm91bmRcbiAgICAgIGNvbnN0IHVwZGF0ZWRTdGF0ZSA9IG1vdmVUb05leHRQbGF5ZXIobmV3U3RhdGUpO1xuXG4gICAgICAvLyBSZXN0YXJ0IHRpbWVyIGZvciBuZXh0IHBsYXllci9yb3VuZCBpZiBnYW1lIGlzbid0IG92ZXJcbiAgICAgIGlmICghdXBkYXRlZFN0YXRlLmlzR2FtZU92ZXIpIHtcbiAgICAgICAgc2V0SXNUaW1lclJ1bm5pbmcodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkU3RhdGU7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlVGltZVVwID0gKCkgPT4ge1xuICAgIHNldElzVGltZXJSdW5uaW5nKGZhbHNlKTtcblxuICAgIC8vIEF1dG8tc3VibWl0IHdyb25nIGFuc3dlciBmb3IgY3VycmVudCBwbGF5ZXIgaWYgdGhleSBoYXZlbid0IGFuc3dlcmVkXG4gICAgaWYgKCFnYW1lU3RhdGUuaGFzQW5zd2VyZWRbZ2FtZVN0YXRlLmN1cnJlbnRQbGF5ZXJJbmRleF0pIHtcbiAgICAgIGhhbmRsZUFuc3dlcihnYW1lU3RhdGUuY3VycmVudFBsYXllckluZGV4LCBmYWxzZSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZvcmZlaXRHYW1lID0gKHBsYXllckluZGV4OiBudW1iZXIpID0+IHtcbiAgICBzZXRHYW1lU3RhdGUoKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5wcmV2IH07XG4gICAgICBuZXdTdGF0ZS5pc0dhbWVPdmVyID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHdpbm5lciA9IG5ld1N0YXRlLnBsYXllcnNbMSAtIHBsYXllckluZGV4XTsgLy8gT3RoZXIgcGxheWVyIHdpbnNcbiAgICAgIG9uR2FtZUNvbXBsZXRlPy4od2lubmVyKTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9KTtcbiAgICBzZXRJc1RpbWVyUnVubmluZyhmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBnYW1lU3RhdGUsXG4gICAgaW5pdGlhbGl6ZVBsYXllcnMsXG4gICAgaGFuZGxlQW5zd2VyLFxuICAgIGZvcmZlaXRHYW1lLFxuICAgIGlzVGltZXJSdW5uaW5nLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlR2FtZVN0YXRlIiwiaW5pdGlhbFJvdW5kcyIsInRpbWVQZXJUdXJuIiwib25HYW1lQ29tcGxldGUiLCJnZW5lcmF0ZVF1ZXN0aW9uIiwiZ2FtZVN0YXRlIiwic2V0R2FtZVN0YXRlIiwicGxheWVycyIsIm5hbWUiLCJhdmF0YXIiLCJzY29yZSIsInJvdW5kc1dvbiIsImN1cnJlbnRQbGF5ZXJJbmRleCIsInRpbWVMZWZ0IiwiY3VycmVudFJvdW5kIiwidG90YWxSb3VuZHMiLCJpc0dhbWVPdmVyIiwiY3VycmVudFF1ZXN0aW9uIiwiaGFzQW5zd2VyZWQiLCJpc1RpbWVyUnVubmluZyIsInNldElzVGltZXJSdW5uaW5nIiwidGltZXIiLCJzZXRJbnRlcnZhbCIsInByZXYiLCJjbGVhckludGVydmFsIiwiaGFuZGxlVGltZVVwIiwiaW5pdGlhbGl6ZVBsYXllcnMiLCJwbGF5ZXIxTmFtZSIsInBsYXllcjFBdmF0YXIiLCJwbGF5ZXIyTmFtZSIsInBsYXllcjJBdmF0YXIiLCJtb3ZlVG9OZXh0UGxheWVyIiwiY3VycmVudFN0YXRlIiwibmV4dFBsYXllckluZGV4Iiwicm91bmRTY29yZXMiLCJ3aW5uZXIiLCJoYW5kbGVBbnN3ZXIiLCJwbGF5ZXJJbmRleCIsImlzQ29ycmVjdCIsInRpbWVCb251cyIsIm5ld1N0YXRlIiwicG9pbnRzIiwidXBkYXRlZFN0YXRlIiwiZm9yZmVpdEdhbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/hooks/useGameState.ts\n"));

/***/ })

});